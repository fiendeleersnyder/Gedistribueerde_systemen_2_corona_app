import javax.rmi.ssl.SslRMIClientSocketFactory;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.security.*;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Scanner;

public class MatchingService_implementation extends UnicastRemoteObject implements MatchingService{
    Registry myRegistryRegistrar;
    Registry myRegistryMixingProxy;
    Registrar registrar;
    MixingProxy mixingProxy;
    PublicKey publicKeyDoctor;
    byte[] signatureDoctor;
    ArrayList <byte []> pseudonymList;
    ArrayList <usedToken> infectedTokens;
    ArrayList<Capsule> capsules;

    public MatchingService_implementation() throws RemoteException, NotBoundException {
        myRegistryRegistrar = LocateRegistry.getRegistry("localhost", 4500);
        registrar = (Registrar) myRegistryRegistrar.lookup("Registrar");


        myRegistryMixingProxy = LocateRegistry.getRegistry("localhost", 9000, new SslRMIClientSocketFactory());
        mixingProxy = (MixingProxy) myRegistryMixingProxy.lookup("MixingProxy");
    }

    public void uploadFileToMatchingServer(byte[] mydata,  byte[] signature, PublicKey publicKey) throws IOException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
        this.signatureDoctor = signature;
        this.publicKeyDoctor = publicKey;
        try {
            File serverpathfile = new File("logMatchingService.txt");
            FileOutputStream out=new FileOutputStream(serverpathfile);
            byte [] data=mydata;
            out.write(data);
            out.flush();
            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        Signature sign = Signature.getInstance("SHA256withRSA");
        sign.initVerify(publicKeyDoctor);
        //file omzetten naar een byte array zodat deze gesigned kan worden
        File clientpathfile = new File("logMatchingService.txt");
        byte [] fileToSign=new byte[(int) clientpathfile.length()];
        FileInputStream in=new FileInputStream(clientpathfile);
        in.read(fileToSign, 0, fileToSign.length);
        in.close();

        sign.update(fileToSign);
        boolean signed = sign.verify(signatureDoctor);

        if(signed){
            System.out.println("Matching Service is done writing data...");
            //hier log.txt uitlezen
            File file = new File("logMatchingService.txt");
            Scanner sc = new Scanner(file);
            while (sc.hasNextLine()){
                String lijn = sc.nextLine();
                String[] split= lijn.split(" ");
                LocalTime begin = LocalTime.parse(split[1]);
                LocalTime eind = LocalTime.parse(split[2]);
                byte[] hash = split[3].getBytes(StandardCharsets.UTF_8);
                int randomnummer = Integer.parseInt(split[4]);
                infectedTokens.add(new usedToken(begin, eind, hash, randomnummer));
            }

            pseudonymList = registrar.getPseudonyms();

            for (usedToken token: infectedTokens) {
                Iterator<byte[]> iterator = pseudonymList.iterator();
                while(iterator.hasNext()){
                    byte [] pseudo = iterator.next();
                    if (Arrays.equals(token.getHash(), makeHash(pseudo, token.getRandomNumber()))) {
                        //if ()
                    }
                }

            }
        }
        else System.out.println("An error occurred: the signature provided by the doctor and the signature" +
                " generated by the matching service don't match.");
    }


    public void sendCapsules(ArrayList<Capsule> capsulesLijst) throws RemoteException {
        for (Capsule capsule: capsulesLijst) {
            capsules.add(capsule);
        }
    }

    public byte[] makeHash(byte[] pseudonym, int random) throws NoSuchAlgorithmException {
        String data = pseudonym + "," +  random;
        MessageDigest md = MessageDigest.getInstance("SHA3-256");
        return md.digest(data.getBytes(StandardCharsets.UTF_8));
    }

    //public boolean checkTimeInterval()
}
